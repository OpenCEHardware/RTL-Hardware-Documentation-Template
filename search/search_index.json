{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the OpenCEHardware RTL hardware module documentation template. This document provides a standardized structure for documenting hardware designs based on RTL. The template is designed to assist in organizing and presenting technical documentation for hardware modules, facilitating a clear and comprehensive description of the design.</p>"},{"location":"#description","title":"Description","text":"<p>This documentation template is based on multiple sources and industry best practices. It includes detailed sections to cover all important aspects of an RTL hardware design, from the general description of the module to specific details of its HDL implementation.</p> <p>Even though this template is designed for complex desings, its principles can be applied to smaller, simpler designs. It may also guide novice hardware architects toward potential upgrades for their designs.</p> <p>Disclaimer</p> <p>This template excludes any post-silicon or physical design implementation details, such as reliability floorplans, pin mapping, SRAM placement, chip area, power, physical debugging, etc. The focus of this template is on FPGA constraint RTL designs.</p>"},{"location":"#navigation","title":"Navigation","text":"<p>The template is organized into the following sections, each explaining its purpose, general structure, tips, and examples.</p> <p>Note</p> <p>The References and Revisions sections serve a dual purpose, serving both as a example and keeping the actual revisions and references for the template.</p> <ul> <li> Revisions: Documentation on previous versions and changes made.</li> <li> Document Conventions: Definitions and abbreviations used in the document.</li> <li> Introduction: General description of the block and its features.</li> <li> Block Diagram: Visual representation of the block's microarchitecture.</li> <li> Configuration: Information about parameters, typedefs, and RTL interfaces.</li> <li> Protocols: Details of communication and operation protocols.</li> <li> Memory Map: Distribution of memory and resource allocation.</li> <li> Registers: Description of the registers used in the system.</li> <li> Clock Domains: Information about clocks and their management in the system.</li> <li> Reset Domains: Information about reset mechanisms and their domains.</li> <li> Interrupts: Management and handling of interrupts in the system.</li> <li> Arbitration: Arbitration mechanisms for access to shared resources.</li> <li> Debugging: Techniques and tools for system debugging.</li> <li> Synthesis: Summary and results of the design synthesis.</li> <li> Verification: Test environments, verification and testbenches applied to the system.</li> <li>Microarchitecture:<ul> <li> Sub-module 1: Details of the first sub-module of the microarchitecture.</li> <li> Sub-module 2: Details of the second sub-module of the microarchitecture.</li> </ul> </li> </ul>"},{"location":"#using-the-template","title":"Using the Template","text":"<p>This template is designed to be downloaded and adapted to the specific needs of each project. It is recommended to follow the provided structure and customize it according to the design requirements and project standards. Simpler designs may not require documentation for all sections. In such cases, it is recommended to indicate that the section is not needed rather than leaving it blank or excluding it from the document.</p> <p>This template was created using MkDocs, a widely used tool for code documentation (e.g., ReadTheDocs). MkDocs uses Markdown, which is excellent for creating interactive, easy-to-understand documentation. It also integrates seamlessly with GitHub and can be published as a web page (e.g., using GitHub Pages). Additionally, it can be rendered as a PDF, as provided in this template. MkDocs supports themes that offer further customizability and aesthetics. This template uses Material for MkDocs, which offers a comprehensive guide for styling that is well worth exploring.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This template has been developed from various sources and industry standards to ensure comprehensive and useful documentation for RTL hardware design. Please check the References section for more information.</p>"},{"location":"about/","title":"Authors","text":"<p>This documentation template has been developed as part of a graduation project in Computer Engineering. Below are the authors responsible for the creation and development of this document:</p> <ul> <li>Alejandro Chavarr\u00eda</li> <li>Alejandro Soto</li> </ul> <p>This documentation template has been designed to provide a clear and comprehensive structure for the technical description of RTL hardware modules. We extend our gratitude to all collaborators and sources that contributed to the creation of this template.</p> <p>For more information about the project, please refer to the associated GitHub organization OpenCEHardware.</p>"},{"location":"block/arbitration/","title":"Arbitration, Fairness, QoS, and Forward Progress Guarantees","text":"<p>This section addresses how the design handles arbitration between multiple traffic classes or concurrent transaction types that share resources or interfaces. It outlines the arbitration policies, fairness properties, QoS features, and forward progress guarantees [1].</p>"},{"location":"block/arbitration/#arbitration-and-fairness","title":"Arbitration and Fairness","text":"<p>Define the arbitration policy for shared resources or interfaces. Describe how multiple traffic classes or transaction types are prioritized and how fairness is ensured. If applicable, detail any configurability features that allow adjustments to the arbitration policy or QoS settings. Clearly state if any traffic classes are unfairly treated and discuss the implication [1].</p> <ul> <li>Arbitration Policy: Describe the policy used for arbitration (e.g., round-robin, priority-based).</li> <li>Fairness: Explain how fairness is maintained among traffic classes.</li> <li>Configurability: Detail any features that allow users to control arbitration or QoS.</li> </ul>"},{"location":"block/arbitration/#quality-of-service-qos","title":"Quality-of-Service (QoS)","text":"<p>Discuss the QoS mechanisms implemented in the design. Describe how the system ensures different levels of service based on traffic class or transaction type, and how these mechanisms impact system performance [1].</p> <ul> <li>QoS Features: List and describe the QoS features supported by the design.</li> <li>Impact on Performance: Explain how QoS affects the performance of the system.</li> </ul>"},{"location":"block/arbitration/#forward-progress-guarantees","title":"Forward Progress Guarantees","text":"<p>Ensure that the design provides forward progress guarantees, meaning that it avoids deadlock and livelock conditions. State any assumptions about the external system required to guarantee forward progress. Provide a high-level outline of the proof for these guarantees, and indicate if it can be formally verified [1].</p> <ul> <li>Deadlock and Livelock Prevention: Describe how the design prevents deadlock and livelock.</li> <li>Assumptions: State any assumptions needed for forward progress.</li> <li>Proof Outline: Provide a brief outline of the proof or verification approach for forward progress guarantees.</li> </ul>"},{"location":"block/clocks/","title":"Clock Domains","text":"<p>This section provides a detailed overview of the clock domains used in the design. For each clock, indicate its nominal frequency and the supported dynamic range. Include the same top-level block diagram as before, but this time annotate it to show which submodules are in each clock domain. Clock domain crossings in the data path should be explicitly drawn and encapsulated within one or more submodules. For clocks used for \"backbone\" functions spanning many submodules (e.g., a CSR bus in its own clock domain), indicate this clearly and refer to another document or appropriate section for details [1].</p>"},{"location":"block/clocks/#clock-domain-table","title":"Clock Domain Table","text":"Clock Domain Nominal Frequency Supported Dynamic Range Clock Domain 1 XX MHz YY MHz - ZZ MHz Clock Domain 2 AA MHz BB MHz - CC MHz Clock Domain 3 DD MHz EE MHz - FF MHz"},{"location":"block/clocks/#annotated-block-diagram","title":"Annotated Block Diagram","text":""},{"location":"block/configuration/","title":"Configuration","text":"<p>This section includes tables of typedefs, design parameters, and interfaces. In general, it addresses any configurability encoded into the design via RTL. Include the main parameters of the block (both private and shared), the top-level module parameters, and preprocessor macros that set global constants. Do not include parameters or macros that are derived from others. Ensure to describe any constraints and assumptions about reasonable or default values. Only explain the types that are necessary to fully define the parameters and interfaces [1].</p>"},{"location":"block/configuration/#parameters","title":"Parameters","text":"Parameter Name Type Description Default Value Range/Possible Values <code>PARAM1</code> <code>int</code> Brief description of the parameter. <code>10</code> <code>0</code> to <code>100</code> <code>PARAM2</code> <code>float</code> Brief description of the parameter. <code>0.5</code> <code>0.0</code> to <code>1.0</code> <code>PARAM3</code> <code>bool</code> Brief description of the parameter. <code>true</code> <code>true</code>, <code>false</code>"},{"location":"block/configuration/#typedefs","title":"Typedefs","text":"Typedef Name Type Description <code>typedef_name1</code> <code>struct</code> Brief description of what the typedef defines. <code>typedef_name2</code> <code>enum</code> Brief description of what the typedef defines. <code>typedef_name3</code> <code>union</code> Brief description of what the typedef defines."},{"location":"block/configuration/#interfaces","title":"Interfaces","text":"<p>This section includes a table of top-level module interfaces. Group related ports as a single interface. Show the directions and types of the ports, describe the interface's purpose, and follow common naming conventions. Mention the use of any standard protocols. Avoid excessive abbreviations. The directions, types, and names of the ports should match the RTL ports 1:1. The port directions should be from the block's perspective (as in the RTL) [1].</p>"},{"location":"block/configuration/#interface-1","title":"Interface 1","text":"Port Name Direction Type Description <code>port_name</code> Input <code>type</code> Brief description of what this port does. <code>port_name</code> Output <code>type</code> Brief description of what this port does. <code>port_name</code> In/Out <code>type</code> Brief description of what this port does. <p>Protocol Use: Mention any standard protocol used by this interface here, if applicable.</p>"},{"location":"block/configuration/#interface-2","title":"Interface 2","text":"Port Name Direction Type Description <code>port_name</code> Input <code>type</code> Brief description of what this port does. <code>port_name</code> Output <code>type</code> Brief description of what this port does. <code>port_name</code> In/Out <code>type</code> Brief description of what this port does. <p>Protocol Use: Mention any standard protocol used by this interface here, if applicable.</p>"},{"location":"block/conventions/","title":"Document Conventions","text":"<p>This section lists the conventions in terms of definitions and abbreviations that will be used throughout the document. It allows the reader to become familiar with the authors' terminology and establishes a contract with the reader. External links can also be added for further insights.</p>"},{"location":"block/conventions/#glossary","title":"Glossary","text":"<p>List of important words:</p> <ul> <li>Word: Meaning</li> <li>Word: Meaning</li> <li>Word: Meaning</li> </ul>"},{"location":"block/conventions/#abbreviations","title":"Abbreviations","text":"<p>List of important abbreviations:</p> <ul> <li>ABC: Meaning</li> <li>ABC: Meaning</li> <li>ABC: Meaning</li> </ul>"},{"location":"block/debugging/","title":"Debugging","text":"<p>This section describes the debugging mechanisms and non-mission-mode features available in the design. It includes details about debugging registers, debugging interfaces, and any special features that facilitate diagnostics and testing.</p> <p>Warning</p> <p>Testbenches do not count as debugging mechanisms!</p>"},{"location":"block/diagram/","title":"Top-Level Block Diagram","text":"<p>The top-level block diagram should indicate the block boundary and all major interfaces. Draw the top-level submodules and show how they connect internally, but avoid displaying excessive internal implementation detail. The structure of the top-level block diagram should correspond 1:1 with the contents of the top-level RTL module. Avoid \"free-floating\" logic at the top level (everything should be encapsulated in submodules) [1].</p> <p>Tip</p> <p>Markdown allows embedded HTML. With the help of diagramming software (like draw.io), you can hyperlink the diagram to different sections of the document or even external links.</p>"},{"location":"block/diagram/#example","title":"Example","text":""},{"location":"block/interrupts/","title":"Interrupts","text":"<p>This section describes the interrupts implemented in the design. For each interrupt, specify its name, the associated interrupt controller, number, priority, type (e.g., level or edge), triggering mechanism (e.g., rising/falling edge or high/low level), handling method (e.g., synchronous or asynchronous), and a brief description.</p>"},{"location":"block/interrupts/#interrupt-table","title":"Interrupt Table","text":"Interrupt Name Controller Number Priority Type Triggers Handling Description IRQ_1 Main 0 1 Edge Falling Synchronous Description of IRQ_1 IRQ_2 Aux 1 3 Level High Asynchronous Description of IRQ_2"},{"location":"block/introduction/","title":"Introduction","text":"<p>This section provides a description of the block. It briefly covers, at a high level, what the block does and presents a \"bird's-eye\" black-box view of the top-level module. It discusses the goals and non-goals of the block, how it is intended to integrate into a larger system, lists standard protocols, highlights important performance requirements, and touches on debugging features. It outlines the design methodology (coding language, internal and third-party libraries and IPs), and anything else a verification engineer should know before writing the first draft of the test plan [1]. Most of these concepts can be expressed as a list of features, as seen in an I\u00b2C-Master Core Specification [2] example.</p>"},{"location":"block/introduction/#features","title":"Features","text":"<p>In a list of sentences, this section expresses what the block is capable of and its most notable characteristics.</p>"},{"location":"block/introduction/#integration","title":"Integration","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/introduction/#performance","title":"Performance","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/introduction/#design","title":"Design","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/introduction/#debugging","title":"Debugging","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/memory/","title":"Memory Map","text":"<p>This section provides a clear and organized overview of how memory is distributed in the system. It includes a table that shows memory addresses, specific regions assigned to different system components (such as ROM, RAM, peripherals, CSRs, etc.), and any relevant details about the size, access permissions, and purpose of each region. Detailed memory resource allocation facilitates the design, development, use, and debugging of the system.</p>"},{"location":"block/memory/#memory-map-table","title":"Memory Map Table","text":"Memory Address Size Region Description 0x00000000 - 0x0000FFFF 64 KB ROM (Firmware) Contains the boot code and firmware. 0x00010000 - 0x0001FFFF 64 KB RAM (Data) Stores variable data and stacks. 0x00020000 - 0x0002FFFF 64 KB Peripheral A Control and data registers of Peripheral A. 0x00030000 - 0x0003FFFF 64 KB Peripheral B Control and data registers of Peripheral B. 0x00040000 - 0x0004FFFF 64 KB RAM (Stack) Reserved space for the stack and temporary storage."},{"location":"block/protocols/","title":"Protocols","text":"<p>For all interfaces that use a standard industry protocol or an internal/proprietary protocol, list them here and link to the relevant specifications that govern those protocols. If any interfaces use custom protocols that are not defined elsewhere, define them in detail here, with one subsection per protocol. Make sure to define any protocols that involve more than one interface [1]. For custom protocols, feel free to add as much information as needed so they can be easily understood, used, and tested.</p>"},{"location":"block/protocols/#standard-protocols","title":"Standard Protocols","text":""},{"location":"block/protocols/#protocol-1","title":"Protocol 1","text":"<ul> <li>Description: Brief description of the protocol.</li> <li>Specification: Link to the protocol specification.</li> </ul>"},{"location":"block/protocols/#protocol-2","title":"Protocol 2","text":"<ul> <li>Description: Brief description of the protocol.</li> <li>Specification: Link to the protocol specification.</li> </ul>"},{"location":"block/protocols/#custom-protocols","title":"Custom Protocols","text":""},{"location":"block/protocols/#custom-protocol-1","title":"Custom Protocol 1","text":"<ul> <li>Description: Detailed description of the custom protocol.</li> <li>Involved Interfaces: List of interfaces that use this protocol.</li> <li>Data Format: Definition of the data format exchanged.</li> <li>Communication Sequence: Details about the communication sequence between interfaces.</li> </ul>"},{"location":"block/protocols/#custom-protocol-2","title":"Custom Protocol 2","text":"<ul> <li>Description: Detailed description of the custom protocol.</li> <li>Involved Interfaces: List of interfaces that use this protocol.</li> <li>Data Format: Definition of the data format exchanged.</li> <li>Communication Sequence: Details about the communication sequence between interfaces.</li> </ul>"},{"location":"block/references/","title":"References","text":"<p>Link to other related documents\u2009\u2014\u2009test plans, design information, source code location, protocol documents, chip-level specifications, etc. [1] Also link to any external papers, hardware, protocols or ideas used in the document.</p> <p>In this case the example links to the actual refernces used to elaborate this guide.</p> <p> [1] Gottscho, M. (2024, February 20). A Template for Writing a Microarchitecture Specification. Retrieved from https://markgottscho.com/posts/2024/02/20/uarch-spec-template/</p> <p> [2] Herveille, R. (2003, July 3). I\u00b2C-Master Core Specification (Rev. 0.9). OpenCores. Retrieved from https://github.com/freecores/i2c/blob/master/doc/i2c_specs.pdf</p>"},{"location":"block/registers/","title":"Registers","text":"<p>This section contains all the registers of the block, organized in tables. This includes user registers, CSRs, and other registers (e.g., debugging).</p>"},{"location":"block/registers/#user-registers","title":"User Registers","text":""},{"location":"block/registers/#user-registers-table","title":"User Registers Table","text":"Register Name Abbreviation Address Fields and Offsets Access Permissions (HW/SW) Description USER_REG_1 UR1 0x0100 FIELD1 (0-7) R/W Description of User Register 1 USER_REG_2 UR2 0x0104 FIELD1 (0-15) R Description of User Register 2"},{"location":"block/registers/#csrs-configurationstatus-registers","title":"CSRs (Configuration/Status Registers)","text":"<p>List major categories of configuration/status registers (CSRs). Define all CSRs here or link to an external document. Every CSR should define its name, address, fields and offsets, hardware and software access permissions, and a description of what each field does [1].</p> <p>Note</p> <p>Ideally, this subsection should link to CSR documentation that is auto-generated from a single-source-of-truth source code. An open-source industry tool used for this purpose is PeakRDL.</p>"},{"location":"block/registers/#csrs-table","title":"CSRs Table","text":"CSR Name Abbreviation Address Fields and Offsets Access Permissions (HW/SW) Description CSR_NAME_1 CSR1 0x0000 FIELD1 (0-7), FIELD2 (8-15) R/W Description of CSR 1 CSR_NAME_2 CSR2 0x0004 FIELD1 (0-3), FIELD2 (4-7), FIELD3 (8-15) R/W Description of CSR 2"},{"location":"block/registers/#other-registers","title":"Other Registers","text":""},{"location":"block/registers/#other-registers-table","title":"Other Registers Table","text":"Register Name Abbreviation Address Fields and Offsets Access Permissions (HW/SW) Description DEBUG_REG_1 DR1 0x0200 FIELD1 (0-7), FIELD2 (8-15) R/W Description of Debug Register 1 DEBUG_REG_2 DR2 0x0204 FIELD1 (0-3), FIELD2 (4-7), FIELD3 (8-15) R/W Description of Debug Register 2"},{"location":"block/resets/","title":"Reset Domains","text":"<p>This section provides an overview of the reset domains used in the design. For each reset, specify whether it is synchronous or asynchronous, its active level (high or low), and, if synchronous, the associated clock. Include the same top-level block diagram as before, but this time annotate it to show which submodules are in each reset domain. Reset domain crossings in the datapath should be explicitly shown and encapsulated within one or more submodules. For resets used for \"backbone\" functions that span multiple submodules (e.g., a CSR bus in its own reset domain), clearly indicate this and defer detailed information to an appropriate document or section. If the reset protocol is custom to this block, include a subsection defining the relevant procedures. Otherwise, cite other documents that provide these details [1].</p>"},{"location":"block/resets/#reset-domains-table","title":"Reset Domains Table","text":"Reset Name Synchronous/Asynchronous Active High/Low Associated Clock (if synchronous) Description RESET_1 Synchronous Active Low CLK1 Description of RESET_1 RESET_2 Asynchronous Active High N/A Description of RESET_2"},{"location":"block/resets/#annotated-block-diagram","title":"Annotated Block Diagram","text":""},{"location":"block/resets/#custom-reset-procedures","title":"Custom Reset Procedures","text":"<p>If the reset protocol is custom for this block, provide a detailed description of the procedures and mechanisms here. Otherwise, cite the relevant documentation.</p>"},{"location":"block/resets/#custom-reset-procedure","title":"Custom Reset Procedure","text":"<ol> <li>Step 1 of the procedure.</li> <li>Step 2 of the procedure.</li> <li>Step 3 of the procedure.</li> </ol>"},{"location":"block/resets/#references-to-external-documents","title":"References to External Documents","text":"<p>For standard reset protocols, refer to the following documents:</p> <ul> <li>Standard Reset Protocol Document 1</li> <li>Standard Reset Protocol Document 2</li> </ul>"},{"location":"block/revisions/","title":"Revisions","text":"<p>Continually maintain the following table of major and minor revisions of the specification, even if using a version control system like Git. Use a common version naming convention that can be shared with other related blocks. Always write dates in ISO standard form, i.e., YYYY-MM-DD [1].</p> <p>In this case, the example table corresponds to the actual revisions of this document.</p> Date (YYYY-MM-DD) Version Description of Changes Author 2024-08-07 <code>1.0.0</code> Document creation. Alejandro Chavarr\u00eda 2024-08-08 <code>1.0.1</code> Fixed diagram and navigation. Alejandro Chavarr\u00eda"},{"location":"block/synthesis/","title":"Synthesis","text":"<p>This section presents the synthesis results of the design across different FPGAs. It includes a table displaying performance, area, and other relevant parameters for each evaluated FPGA.</p>"},{"location":"block/synthesis/#synthesis-results-table","title":"Synthesis Results Table","text":"FPGA Maximum Frequency (MHz) Area (LUTs) Area (FFs) Area (BRAMs) Area (DSPs) Comments FPGA_A 200 5000 3000 10 20 Description of performance and area for FPGA_A FPGA_B 250 4800 2800 12 18 Description of performance and area for FPGA_B FPGA_C 180 5200 3100 8 22 Description of performance and area for FPGA_C"},{"location":"block/synthesis/#additional-comments-optional","title":"Additional Comments (Optional)","text":"<p>In this section, provide additional comments on the synthesis results, including observations on performance, optimization, and recommendations for future improvements or adjustments.</p>"},{"location":"block/synthesis/#observations","title":"Observations","text":"<ul> <li>Performance: Comment on the differences in maximum frequency achieved across different FPGAs and possible reasons for these differences.</li> <li>Area: Analyze how the area used varies among different FPGAs and if there are opportunities for optimization.</li> <li>Recommendations: Offer recommendations for design improvements based on the synthesis results.</li> </ul>"},{"location":"block/verification/","title":"Verification","text":"<p>This section details the types of tests applied to the block and presents relevant benchmark results.</p>"},{"location":"block/verification/#test-environment","title":"Test Environment","text":"<p>Describe the tools, simulators, or testbeds used for verification and any relevant configuration or parameters for the tests.</p>"},{"location":"block/verification/#test-environment-table","title":"Test Environment Table","text":"Tool Version Relevant Configuration Simulator X 2024.1 Configuration A, Parameter B Tool Y 3.2.1 Configuration C, Parameter D"},{"location":"block/verification/#tests","title":"Tests","text":"<p>Describe the different types of tests applied to the block, such as functional tests, regression tests, and specific verification methodologies used (e.g., simulation, formal verification, emulation).</p>"},{"location":"block/verification/#tests-table","title":"Tests Table","text":"Test Type Description Tools Used Functional Test Verification that the block meets functional specifications. Simulator X, Tool Y Regression Test Ensuring recent changes do not introduce errors in the design. Simulator Z, Test Suite W Formal Verification Rigorous mathematical verification of design properties. Tool A, Tool B"},{"location":"block/verification/#test-results","title":"Test Results","text":"<p>Show the results of the tests applied to the system, ideally in a table format.</p>"},{"location":"block/verification/#benchmarks","title":"Benchmarks","text":"<p>Include benchmark results, such as performance metrics, comparisons with expected outcomes, and block performance under different conditions.</p>"},{"location":"block/verification/#benchmarks-table","title":"Benchmarks Table","text":"Metric Value Comments Maximum Frequency 200 MHz Meets performance expectations. Latency 10 ns Within acceptable limits. Resource Usage 5000 LUTs, 3000 FFs Efficient in terms of utilized resources."},{"location":"block/verification/#benchmarks-results","title":"Benchmarks Results","text":"<p>Show the results of the benchmarks applied to the system, ideally in a table format.</p>"},{"location":"block/verification/#issues-and-resolutions","title":"Issues and Resolutions","text":"<p>Brief discussion of any issues found during verification and how they were resolved.</p>"},{"location":"block/verification/#issues-and-resolutions-table","title":"Issues and Resolutions Table","text":"Issue Description Resolution Simulation Error Results inconsistent with expectations. Adjusted simulator configuration. Timing Error Deviation in response time. Optimized design in critical path."},{"location":"block/verification/#verification-summary","title":"Verification Summary","text":"<p>Provide a brief summary of the block's results from the verification and benchmark processes.</p>"},{"location":"block/microarchitecture/sub1/","title":"Submodule 1","text":""},{"location":"block/microarchitecture/sub1/#description","title":"Description","text":"<p>Provide a description of the submodule here. Explain its function, role within the larger system, and any important design considerations or features.</p>"},{"location":"block/microarchitecture/sub1/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/sub1/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/sub1/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/sub1/#submodule-diagram","title":"Submodule Diagram","text":"<p>Include a diagram of the submodule here, showing its inputs, outputs, and how they are connected internally. Ensure the diagram is clear and properly labeled to facilitate understanding.</p>"},{"location":"block/microarchitecture/sub1/#systemverilog-implementation","title":"SystemVerilog Implementation","text":"<p>Include a brief description of the SystemVerilog code for the submodule, highlighting key parts of the implementation if needed for a clearer understanding.</p> <p>Tip</p> <p>Mkdocs allows a plethora of highlighting and cues for better code documentation. Read more.</p>"},{"location":"block/microarchitecture/sub1/#example-code","title":"Example Code","text":"<pre><code>module Submodule (\n    input  logic input_signal_1,\n    input  logic input_signal_2,\n    output logic output_signal_1,\n    output logic output_signal_2\n);\n  // Description of the submodule's functionality\n\n  // Module logic\n  always_ff @(posedge clk) begin\n    // Implementation of the functionality\n  end\nendmodule\n</code></pre>"},{"location":"block/microarchitecture/sub2/","title":"Submodule 2","text":""},{"location":"block/microarchitecture/sub2/#description","title":"Description","text":"<p>Provide a description of the submodule here. Explain its function, role within the larger system, and any important design considerations or features.</p>"},{"location":"block/microarchitecture/sub2/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/sub2/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/sub2/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/sub2/#submodule-diagram","title":"Submodule Diagram","text":"<p>Include a diagram of the submodule here, showing its inputs, outputs, and how they are connected internally. Ensure the diagram is clear and properly labeled to facilitate understanding.</p>"},{"location":"block/microarchitecture/sub2/#systemverilog-implementation","title":"SystemVerilog Implementation","text":"<p>Include a brief description of the SystemVerilog code for the submodule, highlighting key parts of the implementation if needed for a clearer understanding.</p> <p>Tip</p> <p>Mkdocs allows a plethora of highlighting and cues for better code documentation. Read more.</p>"},{"location":"block/microarchitecture/sub2/#example-code","title":"Example Code","text":"<pre><code>module Submodule (\n    input  logic input_signal_1,\n    input  logic input_signal_2,\n    output logic output_signal_1,\n    output logic output_signal_2\n);\n  // Description of the submodule's functionality\n\n  // Module logic\n  always_ff @(posedge clk) begin\n    // Implementation of the functionality\n  end\nendmodule\n</code></pre>"}]}